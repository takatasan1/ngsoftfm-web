<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NGSoftFM Web</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b0f19;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --border: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --brand: #7c3aed;
      --brand2: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --good: #22c55e;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f5f7fb;
        --panel: rgba(0,0,0,.04);
        --panel2: rgba(0,0,0,.06);
        --border: rgba(0,0,0,.10);
        --text: rgba(0,0,0,.86);
        --muted: rgba(0,0,0,.62);
        --shadow: 0 12px 36px rgba(0,0,0,.10);
      }
    }

    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      min-height: 100vh;
      background:
        radial-gradient(1000px 500px at 10% -10%, rgba(124,58,237,.35), transparent 60%),
        radial-gradient(800px 420px at 90% 0%, rgba(34,197,94,.22), transparent 55%),
        radial-gradient(900px 600px at 50% 110%, rgba(59,130,246,.18), transparent 60%),
        var(--bg);
      color: var(--text);
    }
    a { color: inherit; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .app { max-width: 1240px; margin: 0 auto; padding: 18px; }
    .topbar {
      position: sticky;
      top: 12px;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 14px;
      border-radius: 18px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.06));
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
    }
    @media (max-width: 860px) {
      .topbar { position: static; }
    }
    h1 { margin: 0; font-size: 22px; letter-spacing: .2px; }
    .sub { color: var(--muted); font-size: 13px; }

    .layout {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 14px;
      margin-top: 14px;
      align-items: start;
    }
    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
    }
    .panel { display: grid; gap: 14px; }
    .panel.full { grid-column: 1 / -1; }

    .sectionHead {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }
    h2 {
      margin: 0;
      font-size: 12px;
      letter-spacing: .22em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .small { font-size: 12px; }
    .kpi {
      border: 1px solid var(--border);
      background: var(--panel2);
      border-radius: 14px;
      padding: 10px 12px;
      min-width: 220px;
    }
    .kpiTitle { font-size: 12px; color: var(--muted); }
    .kpiValue { font-size: 14px; color: var(--text); margin-top: 6px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1; }

    .nowPlaying {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      padding: 14px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(124,58,237,.14), rgba(255,255,255,.04));
      margin-bottom: 12px;
    }
    .nowTop {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .navBtn {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      font-size: 26px;
      line-height: 1;
    }
    .navBtn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    .nowFreq {
      font-size: 34px;
      font-weight: 760;
      letter-spacing: .02em;
      line-height: 1.05;
      font-variant-numeric: tabular-nums;
    }
    .nowName {
      font-size: 16px;
      color: var(--muted);
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .card {
      background: linear-gradient(180deg, var(--panel), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 18px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      align-items: end;
    }
    label { display: grid; gap: 6px; font-size: 12px; color: var(--muted); }
    input, select {
      width: 100%;
      font-size: 15px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.14);
      color: var(--text);
      outline: none;
    }
    @media (prefers-color-scheme: light) {
      input, select { background: rgba(255,255,255,.7); }
    }
    input:focus, select:focus { border-color: rgba(124,58,237,.65); box-shadow: 0 0 0 4px rgba(124,58,237,.18); }

    .span-3 { grid-column: span 3; }
    .span-4 { grid-column: span 4; }
    .span-6 { grid-column: span 6; }
    .span-8 { grid-column: span 8; }
    .span-12 { grid-column: span 12; }
    @media (max-width: 860px) {
      .span-3, .span-4, .span-6, .span-8 { grid-column: span 12; }
    }

    .actions { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: flex-end; }
    button {
      font-size: 15px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      cursor: pointer;
    }
    button.primary {
      background: linear-gradient(135deg, rgba(124,58,237,.92), rgba(99,102,241,.88));
      border-color: rgba(124,58,237,.5);
    }
    button.danger {
      background: linear-gradient(135deg, rgba(239,68,68,.90), rgba(244,63,94,.84));
      border-color: rgba(239,68,68,.45);
    }
    button:disabled { opacity: .55; cursor: not-allowed; }

    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .muted { color: var(--muted); }
    .hint { margin: 10px 0 0; color: var(--muted); font-size: 13px; }

    .badges { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel2);
      font-size: 12px;
      color: var(--muted);
    }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: rgba(255,255,255,.25); }
    .dot.good { background: var(--good); }
    .dot.bad { background: var(--bad); }
    .dot.warn { background: var(--warn); }

    .player {
      width: 100%;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px;
      margin-top: 12px;
    }
    #audio { width: 100%; height: 44px; }

    .statusBox {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .statusLine {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel2);
    }
    .statusTitle { font-size: 12px; color: var(--muted); }
    .statusValue { font-size: 14px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    details {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(0,0,0,.06);
      padding: 10px 12px;
    }
    summary { cursor: pointer; color: var(--muted); }
    #status { white-space: pre-wrap; margin: 10px 0 0; font-size: 12px; color: var(--muted); }

    #err {
      color: var(--bad);
      background: rgba(239,68,68,.10);
      border: 1px solid rgba(239,68,68,.25);
      border-radius: 14px;
      padding: 10px 12px;
      white-space: pre-wrap;
      display: none;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translate(-50%, 10px);
      opacity: 0;
      pointer-events: none;
      max-width: min(92vw, 680px);
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.45);
      color: rgba(255,255,255,.92);
      padding: 10px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      transition: opacity .18s ease, transform .18s ease;
      font-size: 13px;
    }
    @media (prefers-color-scheme: light) {
      .toast { background: rgba(255,255,255,.75); color: rgba(0,0,0,.86); }
    }
    .toast.show { opacity: 1; transform: translate(-50%, 0); }

    body.busy {
      cursor: progress;
    }

    .meter {
      height: 7px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      overflow: hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
      margin-top: 8px;
    }
    .meter > span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(124,58,237,.92), rgba(34,197,94,.82));
      transition: width .22s ease;
    }

    .presetList { margin-top: 10px; display: grid; gap: 10px; }

    .presetPicker {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .presetPickerHead {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 8px;
    }
    .presetPager {
      display: grid;
      grid-template-columns: 44px 1fr 44px;
      gap: 10px;
      align-items: center;
    }
    .presetGrid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      grid-template-rows: repeat(3, 1fr);
      grid-auto-flow: column; /* left column top->bottom, then right */
      gap: 10px;
    }
    .presetCell {
      width: 100%;
      min-height: 54px;
      text-align: left;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      cursor: pointer;
    }
    .presetCell:hover { border-color: rgba(255,255,255,.22); }
    .presetCell.active {
      border-color: rgba(124,58,237,.55);
      box-shadow: 0 0 0 4px rgba(124,58,237,.14);
    }
    .presetCell .pFreq { font-weight: 650; font-size: 13px; letter-spacing: .2px; }
    .presetCell .pName { font-size: 12px; color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-top: 2px; }
    .presetEmpty {
      grid-column: 1 / -1;
      padding: 10px 12px;
      border: 1px dashed var(--border);
      border-radius: 14px;
      color: var(--muted);
      background: rgba(255,255,255,.04);
    }
    .presetRow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: var(--panel2);
    }
    .presetRow.active {
      border-color: rgba(124,58,237,.55);
      box-shadow: 0 0 0 4px rgba(124,58,237,.14);
    }
    .presetMain { min-width: 0; display: flex; gap: 10px; align-items: baseline; }
    .presetFreq { font-weight: 650; font-size: 14px; letter-spacing: .2px; }
    .presetName { font-size: 13px; color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .presetActions { display: flex; gap: 8px; align-items: center; }
    .iconBtn {
      width: 36px;
      height: 36px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      cursor: pointer;
      color: var(--text);
      padding: 0;
    }
    .iconBtn:hover { border-color: rgba(255,255,255,.22); }
    .iconBtn svg { width: 16px; height: 16px; opacity: .92; }
    .presetEdit { display: none; gap: 10px; align-items: center; width: 100%; }
    .presetRow.editing .presetView { display: none; }
    .presetRow.editing .presetEdit { display: flex; }
    .presetEdit input { flex: 1; }

    #presetManageDetails > summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      list-style: none;
    }
    #presetManageDetails > summary::-webkit-details-marker { display: none; }
    #presetManageDetails { width: 100%; }
    #presetManageDetails[open] .presetList { margin-top: 10px; }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div>
        <h1>NGSoftFM</h1>
        <div class="sub">ローカル/遠隔（LAN・Tailscale）での FM 受信と再生</div>
      </div>
    </header>

    <main class="layout">
      <section class="panel full">
        <div class="card">
          <div class="sectionHead">
            <h2>Player</h2>
            <div class="badges">
              <span class="badge"><span id="dotStream" class="dot"></span><span id="badgeStream">停止中</span></span>
              <span class="badge"><span id="dotStereo" class="dot"></span><span id="badgeStereo">受信: 不明</span></span>
              <span class="badge"><span class="dot warn"></span><span id="badgeDelivery">配信: -</span></span>
            </div>
          </div>

          <div class="nowPlaying" aria-label="Now Playing">
            <div class="nowTop">
              <button id="presetPrev" class="iconBtn navBtn" type="button" title="前のプリセット">‹</button>
              <div id="playerNowFreq" class="nowFreq mono" style="text-align:center">-</div>
              <button id="presetNext" class="iconBtn navBtn" type="button" title="次のプリセット">›</button>
            </div>
            <div id="playerNowName" class="nowName">-</div>
          </div>

          <div id="err" role="alert" aria-live="polite"></div>

          <div class="player">
            <video id="audio" controls playsinline></video>
          </div>

          <div class="presetPicker" aria-label="プリセット選択">
            <div class="presetPickerHead">
              <span class="muted small">プリセット</span>
              <span id="presetPageInfo" class="muted small"></span>
            </div>
            <div class="presetPager">
              <button id="presetPagePrev" class="iconBtn navBtn" type="button" title="前のページ">‹</button>
              <div>
                <select id="preset" style="display:none"></select>
                <div id="presetGrid" class="presetGrid"></div>
              </div>
              <button id="presetPageNext" class="iconBtn navBtn" type="button" title="次のページ">›</button>
            </div>
          </div>
        </div>
      </section>

      <section class="panel left">
        <div class="card">
          <div class="sectionHead">
            <h2>Tuning</h2>
            <div class="actions">
              <button id="start" class="primary">受信</button>
              <button id="stop" class="danger">停止</button>
              <button id="presetAddCurrent">プリセット追加</button>
              <button id="toggleSettings" title="配信/バッファ等の設定を表示">設定</button>
            </div>
          </div>

          <div class="grid">
            <label class="span-3">
              周波数 (MHz)
              <input id="freq" type="number" step="0.1" value="80.0" inputmode="decimal" />
            </label>



            <label class="span-3 settingOnly hidden">
              配信
              <select id="delivery">
                <option value="hls">HLS (推奨)</option>
                <option value="direct">Direct</option>
              </select>
            </label>

            <label class="span-3 settingOnly hidden">
              形式
              <select id="fmt">
                <option value="mp3">MP3</option>
                <option value="wav">WAV (無圧縮)</option>
                <option value="aac">AAC (HLS専用)</option>
              </select>
            </label>

            <label class="span-3 settingOnly hidden">
              HLS kbps
              <input id="hlsKbps" type="number" step="16" min="32" max="512" value="320" />
            </label>

            <label class="span-3 settingOnly hidden">
              バッファ (秒)
              <input id="buf" type="number" step="0.5" min="0" max="60" value="2" />
            </label>

            <label class="span-3 settingOnly hidden">
              RTL ゲイン (dB)
              <input id="gain" type="number" step="0.1" min="0" max="100" value="19.7" />
            </label>

            <label class="span-3 settingOnly hidden">
              RTL AGC
              <select id="rtlAgc">
                <option value="off">OFF</option>
                <option value="on">ON</option>
              </select>
            </label>

            <label class="span-3">
              出力モード
              <select id="forceStereo">
                <option value="auto">自動</option>
                <option value="stereo">強制ステレオ</option>
                <option value="mono">モノラル</option>
              </select>
            </label>
          </div>

          <details id="presetManageDetails">
            <summary>
              <span class="muted small">プリセット管理（編集/削除）</span>
              <span id="presetManageSummary" class="muted small"></span>
            </summary>
            <div style="margin-top:10px">
              <div id="presetManageList" class="presetList"></div>
            </div>
          </details>

          <p class="hint">ChromeでAAC/Opusを安定再生したい場合はHLSを使います（内部で <code>/hls/stream.m3u8</code> を再生）。</p>
        </div>

        <div class="card">
          <div class="sectionHead">
            <h2>Scanner</h2>
            <span id="scanProgress" class="muted small"></span>
          </div>

          <div class="grid">
            <label class="span-3">開始 MHz<input id="scanStart" type="number" step="0.1" value="76.0" /></label>
            <label class="span-3">終了 MHz<input id="scanEnd" type="number" step="0.1" value="95.0" /></label>
            <label class="span-3">刻み MHz<input id="scanStep" type="number" step="0.1" value="0.1" /></label>
            <label class="span-3">滞在 ms<input id="scanDwell" type="number" step="100" value="600" /></label>
            <label class="span-3">
              しきい値
              <select id="scanLevel">
                <option value="strong">強電界（絞り込み強め）</option>
                <option value="medium" selected>中電界（標準）</option>
                <option value="weak">弱電界（絞り込み弱め）</option>
              </select>
            </label>
            <div class="span-12 actions" style="justify-content:flex-start">
              <button id="scanGo" class="primary">スキャン開始</button>
              <button id="scanStop">スキャン停止</button>
              <button id="scanAddAll">発見局を一括登録</button>
            </div>
          </div>

          <div id="scanResults" class="statusBox"></div>
        </div>

        <div class="card">
          <div class="sectionHead">
            <h2>Server</h2>
            <div class="actions">
              <button id="toggleServerAdmin" title="サーバ再起動UIを表示/非表示">管理</button>
            </div>
          </div>

          <div class="statusBox">
            <div class="statusLine">
              <div>
                <div class="statusTitle">接続先</div>
                <div id="uiUrl" class="statusValue mono">-</div>
              </div>
              <button id="copyUrl" title="URLをコピー">コピー</button>
            </div>
          </div>

          <div id="serverAdminWrap" class="hidden">
            <div class="grid">
              <label class="span-6">
                管理トークン（任意）
                <input id="adminToken" type="password" placeholder="NGSOFTFM_ADMIN_TOKEN を設定している場合に入力" />
              </label>
              <div class="span-6 actions" style="justify-content:flex-start">
                <button id="serverRestart" class="danger">サーバ再起動</button>
                <span id="serverRestartHint" class="muted"></span>
              </div>
            </div>
            <p class="hint">※ 再起動は配信/スキャンを停止し、プロセスを終了します。自動で起動し直すには監視スクリプト（例: <code>scripts/Start-Web.ps1</code>）で起動してください。</p>
          </div>
        </div>
      </section>

      <section class="panel right">
        <div class="card">
          <div class="sectionHead">
            <h2>Status</h2>
            <div class="actions">
              <button id="toggleStatus" title="ステータス表示を切り替え">表示</button>
            </div>
          </div>
          <div id="statusWrap" class="hidden">
            <div id="status">(loading...)</div>
          </div>
        </div>
      </section>
    </main>

    <div id="toast" class="toast" aria-live="polite"></div>
  </div>

  <script>
    // HLS playback:
    // - Chrome/Edge: hls.js (MSE)
    // - Safari: native HLS
    // Try local copy first (/vendor/hls.js), then CDN.
  </script>
  <script src="/vendor/hls.js" onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/hls.js@1'" ></script>
  <script>
    const elFreq = document.getElementById('freq');
    const elPreset = document.getElementById('preset');
    const elScanStart = document.getElementById('scanStart');
    const elScanEnd = document.getElementById('scanEnd');
    const elScanStep = document.getElementById('scanStep');
    const elScanDwell = document.getElementById('scanDwell');
    const elScanLevel = document.getElementById('scanLevel');
    const elAdminToken = document.getElementById('adminToken');
    const elServerRestart = document.getElementById('serverRestart');
    const elServerRestartHint = document.getElementById('serverRestartHint');
    const elScanGo = document.getElementById('scanGo');
    const elScanStop = document.getElementById('scanStop');
    const elScanAddAll = document.getElementById('scanAddAll');
    const elScanProgress = document.getElementById('scanProgress');
    const elScanResults = document.getElementById('scanResults');
    const elDelivery = document.getElementById('delivery');
    const elFmt = document.getElementById('fmt');
    const elBuf = document.getElementById('buf');
    const elHlsKbps = document.getElementById('hlsKbps');
    const elGain = document.getElementById('gain');
    const elRtlAgc = document.getElementById('rtlAgc');
    const elForceStereo = document.getElementById('forceStereo');
    const elStart = document.getElementById('start');
    const elStop = document.getElementById('stop');
    const elAudio = document.getElementById('audio');
    const elStatus = document.getElementById('status');
    const elRxInfo = document.getElementById('rxinfo');
    const elErr = document.getElementById('err');
    const elUiUrl = document.getElementById('uiUrl');
    const elCopyUrl = document.getElementById('copyUrl');
    const elToast = document.getElementById('toast');
    const elPresetGrid = document.getElementById('presetGrid');
    const elPresetPagePrev = document.getElementById('presetPagePrev');
    const elPresetPageNext = document.getElementById('presetPageNext');
    const elPresetPageInfo = document.getElementById('presetPageInfo');
    const elPresetAddCurrent = document.getElementById('presetAddCurrent');
    const elDotStream = document.getElementById('dotStream');
    const elBadgeStream = document.getElementById('badgeStream');
    const elDotStereo = document.getElementById('dotStereo');
    const elBadgeStereo = document.getElementById('badgeStereo');
    const elBadgeDelivery = document.getElementById('badgeDelivery');
    const elPresetManageDetails = document.getElementById('presetManageDetails');
    const elPresetManageSummary = document.getElementById('presetManageSummary');
    const elPresetManageList = document.getElementById('presetManageList');
    const elPlayerNowFreq = document.getElementById('playerNowFreq');
    const elPlayerNowName = document.getElementById('playerNowName');
    const elPresetPrev = document.getElementById('presetPrev');
    const elPresetNext = document.getElementById('presetNext');
    const elToggleSettings = document.getElementById('toggleSettings');
    const elToggleStatus = document.getElementById('toggleStatus');
    const elStatusWrap = document.getElementById('statusWrap');
    const elToggleServerAdmin = document.getElementById('toggleServerAdmin');
    const elServerAdminWrap = document.getElementById('serverAdminWrap');

    let hls = null;
    let isBusy = false;
    let lastScanResults = [];
    let toastTimer = null;
    let lastPresets = [];

    const presetPageSize = 6;
    let presetPageIndex = 0;

    // Preset manage panel open/close state
    try {
      if (elPresetManageDetails) {
        const saved = localStorage.getItem('presetDetailsOpen');
        if (saved === '1') elPresetManageDetails.open = true;
        else if (saved === '0') elPresetManageDetails.open = false;
        elPresetManageDetails.addEventListener('toggle', () => {
          try { localStorage.setItem('presetDetailsOpen', elPresetManageDetails.open ? '1' : '0'); } catch {}
        });
      }
    } catch {}

    function setWrapVisible(wrapEl, visible) {
      if (!wrapEl) return;
      wrapEl.classList.toggle('hidden', !visible);
    }

    function restoreToggleState(key, defaultOpen) {
      try {
        const saved = localStorage.getItem(key);
        if (saved === '1') return true;
        if (saved === '0') return false;
      } catch {}
      return !!defaultOpen;
    }

    function persistToggleState(key, open) {
      try { localStorage.setItem(key, open ? '1' : '0'); } catch {}
    }

    // Settings panel (delivery/buf/etc): hidden by default (except Force Stereo)
    try {
      const settingEls = Array.from(document.querySelectorAll('.settingOnly'));
      const savedOpen = restoreToggleState('settingsOpen', false);
      for (const el of settingEls) el.classList.toggle('hidden', !savedOpen);
      if (elToggleSettings) {
        elToggleSettings.setAttribute('aria-expanded', savedOpen ? 'true' : 'false');
        elToggleSettings.addEventListener('click', () => {
          const anyHidden = settingEls.some(el => el.classList.contains('hidden'));
          const nextOpen = anyHidden;
          for (const el of settingEls) el.classList.toggle('hidden', !nextOpen);
          elToggleSettings.setAttribute('aria-expanded', nextOpen ? 'true' : 'false');
          persistToggleState('settingsOpen', nextOpen);
        });
      }
    } catch {}

    // Status panel: toggle show/hide, hidden by default
    try {
      const open = restoreToggleState('statusOpen', false);
      setWrapVisible(elStatusWrap, open);
      if (elToggleStatus) {
        elToggleStatus.textContent = open ? '隠す' : '表示';
        elToggleStatus.setAttribute('aria-expanded', open ? 'true' : 'false');
        elToggleStatus.addEventListener('click', () => {
          const nextOpen = elStatusWrap ? elStatusWrap.classList.contains('hidden') : true;
          setWrapVisible(elStatusWrap, nextOpen);
          elToggleStatus.textContent = nextOpen ? '隠す' : '表示';
          elToggleStatus.setAttribute('aria-expanded', nextOpen ? 'true' : 'false');
          persistToggleState('statusOpen', nextOpen);
        });
      }
    } catch {}

    // Server admin/restart UI: toggle show/hide, hidden by default
    try {
      const open = restoreToggleState('serverAdminOpen', false);
      setWrapVisible(elServerAdminWrap, open);
      if (elToggleServerAdmin) {
        elToggleServerAdmin.textContent = open ? '閉じる' : '管理';
        elToggleServerAdmin.setAttribute('aria-expanded', open ? 'true' : 'false');
        elToggleServerAdmin.addEventListener('click', () => {
          const nextOpen = elServerAdminWrap ? elServerAdminWrap.classList.contains('hidden') : true;
          setWrapVisible(elServerAdminWrap, nextOpen);
          elToggleServerAdmin.textContent = nextOpen ? '閉じる' : '管理';
          elToggleServerAdmin.setAttribute('aria-expanded', nextOpen ? 'true' : 'false');
          persistToggleState('serverAdminOpen', nextOpen);
        });
      }
    } catch {}

    function toast(msg, ms) {
      if (!elToast) return;
      const t = msg ? String(msg) : '';
      if (!t) return;
      elToast.textContent = t;
      elToast.classList.add('show');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        elToast.classList.remove('show');
      }, Number.isFinite(ms) ? ms : 1800);
    }

    function iconPencilSvg() {
      return '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 20H21" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L8 18l-4 1 1-4 11.5-11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
    }
    function iconTrashSvg() {
      return '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M8 6V4h8v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19 6l-1 14H6L5 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M10 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M14 11v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
    }

    function normalizePresetsPayload(json) {
      if (json && Array.isArray(json.presets)) {
        return json.presets
          .map(p => ({ freqMHz: String(p && p.freqMHz || '').trim(), name: String(p && p.name || '-').trim() || '-' }))
          .filter(p => p.freqMHz.length > 0);
      }
      const mhz = (json && Array.isArray(json.presetsMHz)) ? json.presetsMHz : [];
      return mhz.map(v => ({ freqMHz: String(v).trim(), name: '-' })).filter(p => p.freqMHz.length > 0);
    }

    function findPresetNameByMHz(mhz) {
      const list = Array.isArray(lastPresets) ? lastPresets : [];
      if (!Number.isFinite(mhz)) return '-';
      const key = mhz.toFixed(1);
      const hit = list.find(p => String(p && p.freqMHz) === key);
      const name = hit && hit.name ? String(hit.name).trim() : '';
      return name || '-';
    }

    function getSortedPresetMHz() {
      const list = Array.isArray(lastPresets) ? lastPresets : [];
      const mhz = list
        .map(p => Number(p && p.freqMHz))
        .filter(v => Number.isFinite(v))
        .map(v => Number(v.toFixed(1)));
      const uniq = Array.from(new Set(mhz));
      uniq.sort((a, b) => a - b);
      return uniq;
    }

    function setTuningMHz(mhz) {
      if (!Number.isFinite(mhz)) return;
      elFreq.value = mhz.toFixed(1);
      try {
        if (elPreset) {
          elPreset.value = mhz.toFixed(1);
          elPreset.dispatchEvent(new Event('change'));
        }
      } catch {}
      renderPresetGrid(lastPresets);
      renderPresetManageList(lastPresets);
    }

    function updatePresetNavEnabled() {
      const list = getSortedPresetMHz();
      const enabled = list.length >= 2;
      if (elPresetPrev) elPresetPrev.disabled = !enabled;
      if (elPresetNext) elPresetNext.disabled = !enabled;
    }

    async function navigatePreset(delta) {
      const list = getSortedPresetMHz();
      if (!list.length) {
        toast('プリセットがありません');
        return;
      }

      const cur = Number(elFreq && elFreq.value);
      const curMhz = Number.isFinite(cur) ? Number(cur.toFixed(1)) : null;

      let next;
      const idx = (curMhz === null) ? -1 : list.findIndex(v => v === curMhz);
      if (idx >= 0) {
        next = list[(idx + delta + list.length) % list.length];
      } else if (curMhz === null) {
        next = list[0];
      } else {
        if (delta > 0) next = list.find(v => v > curMhz) ?? list[0];
        else next = [...list].reverse().find(v => v < curMhz) ?? list[list.length - 1];
      }

      setTuningMHz(next);
      await startReceiving(next);
    }

    function sortPresetsForUi(presets) {
      const list = Array.isArray(presets) ? presets : [];
      const cleaned = list
        .map(p => ({
          freqMHz: Number(p && p.freqMHz),
          name: (p && p.name != null) ? String(p.name) : '-'
        }))
        .filter(p => Number.isFinite(p.freqMHz));
      cleaned.sort((a, b) => a.freqMHz - b.freqMHz);
      return cleaned;
    }

    function renderPresetGrid(presets) {
      if (!elPresetGrid) return;
      elPresetGrid.innerHTML = '';

      const list = sortPresetsForUi(presets);
      const totalPages = Math.max(1, Math.ceil(list.length / presetPageSize));
      presetPageIndex = Math.max(0, Math.min(presetPageIndex, totalPages - 1));

      const canPage = totalPages > 1;

      if (elPresetPageInfo) {
        if (!list.length) elPresetPageInfo.textContent = '';
        else elPresetPageInfo.textContent = `${presetPageIndex + 1}/${totalPages} (${list.length}件)`;
      }
      if (elPresetPagePrev) elPresetPagePrev.disabled = !canPage;
      if (elPresetPageNext) elPresetPageNext.disabled = !canPage;

      if (!list.length) {
        const empty = document.createElement('div');
        empty.className = 'presetEmpty';
        empty.textContent = '(登録なし)';
        elPresetGrid.appendChild(empty);
        updatePresetNavEnabled();
        return;
      }

      const cur = Number(elFreq && elFreq.value);
      const curKey = Number.isFinite(cur) ? Number(cur.toFixed(1)) : null;

      const start = presetPageIndex * presetPageSize;
      const page = list.slice(start, start + presetPageSize);
      for (const p of page) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'presetCell';
        const mhz = Number(p.freqMHz);
        if (curKey !== null && Number(mhz.toFixed(1)) === curKey) {
          btn.classList.add('active');
        }

        const name = String(p.name || '-').trim() || '-';
        btn.innerHTML = `<div class="pFreq mono">${mhz.toFixed(1)} MHz</div><div class="pName">${escapeHtml(name)}</div>`;

        btn.addEventListener('click', async () => {
          setTuningMHz(mhz);
          await startReceiving(mhz);
        });

        elPresetGrid.appendChild(btn);
      }

      updatePresetNavEnabled();
    }

    function renderPresetManageList(presets) {
      if (!elPresetManageList) return;
      elPresetManageList.innerHTML = '';

      const list = Array.isArray(presets) ? presets : [];
      if (elPresetManageSummary) {
        const cur = Number(elFreq && elFreq.value);
        const curKey = Number.isFinite(cur) ? cur.toFixed(1) : null;
        const curItem = curKey ? list.find(x => String(x.freqMHz) === curKey) : null;
        const curText = curItem ? `${curItem.freqMHz}MHz ${String(curItem.name || '-').trim() || '-'}` : '';
        elPresetManageSummary.textContent = list.length ? `${list.length}件${curText ? ' / ' + curText : ''}` : '';
      }

      if (!list.length) {
        const empty = document.createElement('div');
        empty.className = 'statusLine';
        empty.innerHTML = '<div class="statusTitle">プリセット</div><div class="statusValue muted">(登録なし)</div>';
        elPresetManageList.appendChild(empty);
        return;
      }

      const cur = Number(elFreq && elFreq.value);
      const curKey = Number.isFinite(cur) ? cur.toFixed(1) : null;

      for (const p of list) {
        const row = document.createElement('div');
        row.className = 'presetRow';

        const view = document.createElement('div');
        view.className = 'presetView';
        view.style.display = 'flex';
        view.style.justifyContent = 'space-between';
        view.style.alignItems = 'center';
        view.style.gap = '12px';
        view.style.width = '100%';

        const main = document.createElement('div');
        main.className = 'presetMain';

        const freq = document.createElement('div');
        freq.className = 'presetFreq mono';
        freq.textContent = `${p.freqMHz} MHz`;

        const name = document.createElement('div');
        name.className = 'presetName';
        name.textContent = (p.name && String(p.name).trim()) ? String(p.name).trim() : '-';

        main.appendChild(freq);
        main.appendChild(name);

        const actions = document.createElement('div');
        actions.className = 'presetActions';

        const btnEdit = document.createElement('button');
        btnEdit.className = 'iconBtn';
        btnEdit.type = 'button';
        btnEdit.title = '編集';
        btnEdit.innerHTML = iconPencilSvg();

        actions.appendChild(btnEdit);
        view.appendChild(main);
        view.appendChild(actions);

        const edit = document.createElement('div');
        edit.className = 'presetEdit';

        const input = document.createElement('input');
        input.type = 'text';
        input.value = (p.name && String(p.name).trim()) ? String(p.name).trim() : '-';
        input.placeholder = '-';

        const btnSave = document.createElement('button');
        btnSave.type = 'button';
        btnSave.className = 'primary';
        btnSave.textContent = '保存';

        const btnDel = document.createElement('button');
        btnDel.type = 'button';
        btnDel.className = 'iconBtn';
        btnDel.title = '削除';
        btnDel.innerHTML = iconTrashSvg();

        const btnCancel = document.createElement('button');
        btnCancel.type = 'button';
        btnCancel.textContent = '取消';

        edit.appendChild(input);
        edit.appendChild(btnSave);
        edit.appendChild(btnDel);
        edit.appendChild(btnCancel);

        row.appendChild(view);
        row.appendChild(edit);

        // Active highlight
        if (curKey && String(p.freqMHz) === curKey) {
          row.classList.add('active');
        }

        // Clicking the row sets tuning frequency.
        row.addEventListener('click', (ev) => {
          if (row.classList.contains('editing')) return;
          // Ignore clicks on buttons.
          if (ev.target && (ev.target.closest && ev.target.closest('button'))) return;
          const mhz = Number(p.freqMHz);
          if (!Number.isFinite(mhz)) return;
          elFreq.value = mhz.toFixed(1);
          // Keep hidden select in sync for legacy behavior.
          if (elPreset) {
            elPreset.value = String(p.freqMHz);
            elPreset.dispatchEvent(new Event('change'));
          }
          renderPresetGrid(lastPresets);
          renderPresetManageList(lastPresets);

          // One-push switch: stop -> start -> play
          startReceiving(mhz);
        });

        btnEdit.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          row.classList.toggle('editing');
          if (row.classList.contains('editing')) {
            input.focus();
            input.select();
          }
        });

        btnCancel.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          row.classList.remove('editing');
        });

        btnSave.addEventListener('click', async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          const mhz = Number(p.freqMHz);
          if (!Number.isFinite(mhz)) return;
          try {
            await api('/api/presets/update', { freqMHz: mhz, name: String(input.value || '-') });
            await loadPresets();
            toast('局名を保存しました');
            setError('');
          } catch (e) {
            setError(e);
          }
        });

        btnDel.addEventListener('click', async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          const ok = confirm(`${p.freqMHz} MHz をプリセットから削除しますか？`);
          if (!ok) return;
          const mhz = Number(p.freqMHz);
          if (!Number.isFinite(mhz)) return;
          try {
            await api('/api/presets/remove', { freqMHz: mhz });
            await loadPresets();
            toast('削除しました');
            setError('');
          } catch (e) {
            setError(e);
          }
        });

        // Save on Enter
        input.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') {
            ev.preventDefault();
            btnSave.click();
          } else if (ev.key === 'Escape') {
            ev.preventDefault();
            btnCancel.click();
          }
        });

        elPresetManageList.appendChild(row);
      }
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function setError(msg) {
      const t = msg ? String(msg) : '';
      elErr.textContent = t;
      elErr.style.display = t ? '' : 'none';
    }

    function setBusy(v) {
      isBusy = !!v;
      elStart.disabled = isBusy;
      // Stop is usually safe, but avoid double-click storms while starting.
      elStop.disabled = isBusy;
      document.body.classList.toggle('busy', isBusy);
      if (isBusy) {
        elStart.textContent = '受信中...';
      } else {
        elStart.textContent = '受信';
      }
    }

    function setBadgeStreaming(streaming) {
      const on = !!streaming;
      elDotStream.className = 'dot ' + (on ? 'good' : '');
      elBadgeStream.textContent = on ? '配信中' : '停止中';
    }

    function setBadgeStereo(stereoDetected) {
      if (typeof stereoDetected !== 'boolean') {
        elDotStereo.className = 'dot';
        elBadgeStereo.textContent = '受信: 不明';
        return;
      }
      elDotStereo.className = 'dot ' + (stereoDetected ? 'good' : 'warn');
      elBadgeStereo.textContent = stereoDetected ? '受信: STEREO' : '受信: MONO';
    }

    function updateUiUrl() {
      try {
        const url = new URL(window.location.href);
        url.hash = '';
        url.search = '';
        elUiUrl.textContent = url.toString();
      } catch {
        elUiUrl.textContent = window.location.href;
      }
    }

    function canPlayDirectFormat(fmt) {
      fmt = String(fmt || '').toLowerCase();
      if (fmt === 'mp3') return !!elAudio.canPlayType('audio/mpeg');
      if (fmt === 'wav') return !!(elAudio.canPlayType('audio/wav') || elAudio.canPlayType('audio/wave') || elAudio.canPlayType('audio/x-wav'));
      return false;
    }

    function applyFormatSupportUI() {
      const options = Array.from(elFmt.options || []);
      for (const opt of options) {
        // For simplicity: direct supports MP3/WAV; AAC is intended via HLS.
        const ok = (opt.value === 'mp3') || (opt.value === 'wav') || (opt.value === 'aac');
        opt.disabled = !ok;
        if (!ok) {
          opt.textContent = opt.textContent.replace(' (非対応)', '') + ' (非対応)';
        }
      }

      applyDeliveryUI();
    }

    function applyDeliveryUI() {
      const delivery = String(elDelivery.value || 'hls');
      const isHls = (delivery === 'hls');

      // HLS bitrate control only relevant in HLS mode.
      elHlsKbps.closest('label').style.display = isHls ? '' : 'none';

      if (isHls) {
        // For now, HLS outputs AAC.
        elFmt.value = 'aac';
        elFmt.disabled = true;
      } else {
        elFmt.disabled = false;

        // Hide HLS-only formats in Direct mode.
        const optAac = elFmt.querySelector('option[value="aac"]');
        if (optAac) {
          optAac.hidden = true;
          optAac.disabled = true;
        }

        if (!canPlayDirectFormat(elFmt.value)) {
          elFmt.value = 'mp3';
        }
      }

      if (isHls) {
        // In HLS mode, show AAC option again.
        const optAac = elFmt.querySelector('option[value="aac"]');
        if (optAac) {
          optAac.hidden = false;
          optAac.disabled = false;
        }
      }
    }

    // Preset paging (Player bottom)
    try {
      if (elPresetPagePrev) {
        elPresetPagePrev.addEventListener('click', () => {
          const totalPages = Math.max(1, Math.ceil((Array.isArray(lastPresets) ? lastPresets.length : 0) / presetPageSize));
          presetPageIndex = (presetPageIndex - 1 + totalPages) % totalPages;
          renderPresetGrid(lastPresets);
        });
      }
      if (elPresetPageNext) {
        elPresetPageNext.addEventListener('click', () => {
          const totalPages = Math.max(1, Math.ceil((Array.isArray(lastPresets) ? lastPresets.length : 0) / presetPageSize));
          presetPageIndex = (presetPageIndex + 1) % totalPages;
          renderPresetGrid(lastPresets);
        });
      }
    } catch {}

    async function api(path, body) {
      const res = await fetch(path, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(body ?? {})
      });
      if (!res.ok) {
        const t = await res.text();
        throw new Error(`${res.status} ${t}`);
      }
      return res.json();
    }

    async function apiPostWithAdminToken(path, body) {
      const token = String((elAdminToken && elAdminToken.value) ? elAdminToken.value : '').trim();
      const headers = { 'content-type': 'application/json' };
      if (token) {
        headers['X-Admin-Token'] = token;
      }
      const res = await fetch(path, {
        method: 'POST',
        headers,
        body: JSON.stringify(body ?? {})
      });
      if (!res.ok) {
        const t = await res.text();
        throw new Error(`${res.status} ${t}`);
      }
      return res.json();
    }

    async function serverRestart() {
      const ok = confirm('サーバを再起動します。\n配信/スキャンは停止し、数秒間アクセスできなくなります。\n実行しますか？');
      if (!ok) return;

      if (elServerRestartHint) elServerRestartHint.textContent = '再起動要求を送信中…';
      try {
        await apiPostWithAdminToken('/api/server/restart', {});
      } catch (e) {
        // サーバが即時終了すると fetch が失敗することがあるので、その場合も続行。
        if (elServerRestartHint) elServerRestartHint.textContent = '再起動中…（応答なし）';
      }

      if (elServerRestartHint) elServerRestartHint.textContent = '再起動中… 5秒後に再読み込みします';
      setTimeout(() => location.reload(), 5000);
    }

    function setPresetOptions(presets) {
      const list = Array.isArray(presets) ? presets : [];
      elPreset.innerHTML = '';
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = '選択…';
      elPreset.appendChild(opt0);

      if (!list.length) {
        const optE = document.createElement('option');
        optE.value = '';
        optE.textContent = '(登録なし)';
        optE.disabled = true;
        elPreset.appendChild(optE);
        lastPresets = [];
        renderPresetGrid(lastPresets);
        renderPresetManageList(lastPresets);
        return;
      }

      for (const p of list) {
        const s = String(p && p.freqMHz || '').trim();
        const n = String(p && p.name || '-').trim() || '-';
        if (!s) continue;
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = `${s} MHz — ${n}`;
        elPreset.appendChild(opt);
      }

      lastPresets = list;
      renderPresetGrid(lastPresets);
      renderPresetManageList(lastPresets);

      // Default open behavior (only when user hasn't chosen a preference)
      try {
        if (elPresetManageDetails) {
          const saved = localStorage.getItem('presetDetailsOpen');
          if (saved !== '0' && saved !== '1') {
            elPresetManageDetails.open = list.length <= 8;
          }
        }
      } catch {}
    }

    async function loadPresets() {
      try {
        const res = await fetch('/api/presets');
        const json = await res.json();
        setPresetOptions(normalizePresetsPayload(json));
      } catch {
        // ignore
      }
    }

    async function scanStart() {
      const startMHz = Number(elScanStart.value);
      const endMHz = Number(elScanEnd.value);
      const stepMHz = Number(elScanStep.value);
      const dwellMs = Number(elScanDwell.value);
      if (!Number.isFinite(startMHz) || !Number.isFinite(endMHz) || !Number.isFinite(stepMHz) || !Number.isFinite(dwellMs)) {
        setError('スキャン条件が不正です');
        return;
      }
      try {
        await api('/api/scan/start', { startMHz, endMHz, stepMHz, dwellMs });
        setError('');
      } catch (e) {
        setError(e);
      }
    }

    async function scanStop() {
      try {
        await api('/api/scan/stop', {});
      } catch {}
    }

    function renderScanResults(status) {
      const running = !!(status && status.running);
      const done = Number(status && status.done);
      const total = Number(status && status.total);
      const err = status && status.error ? String(status.error) : '';
      let curText = '';
      if (running) {
        const startMHz = Number(elScanStart.value);
        const stepMHz = Number(elScanStep.value);
        if (Number.isFinite(startMHz) && Number.isFinite(stepMHz) && Number.isFinite(done)) {
          const curMHz = startMHz + (done * stepMHz);
          if (Number.isFinite(curMHz)) {
            curText = curMHz.toFixed(1);
          }
        }
      }

      elScanProgress.textContent = running
        ? (curText ? `進行中: ${curText} MHz (${done}/${total})` : `進行中: (${done}/${total})`)
        : (total ? `完了: ${done}/${total}` : '');
      if (err) elScanProgress.textContent += ` / error: ${err}`;

      const results = (status && Array.isArray(status.results)) ? status.results : [];
      lastScanResults = results;
      if (!results.length) {
        elScanResults.innerHTML = '<div class="statusLine"><div class="statusTitle">結果</div><div class="statusValue muted">(まだありません)</div></div>';
        return;
      }

      // IF はチューナーにより基準が異なる想定なので、今回の描画バッチ内で min/max を取り、
      // 「最大IFの局がバー最大」になるように相対正規化します。
      const ifValues = [];
      for (const r of results) {
        const v = (r && typeof r.ifDb === 'number') ? r.ifDb : NaN;
        if (Number.isFinite(v)) ifValues.push(v);
      }
      const ifMin = ifValues.length ? Math.min(...ifValues) : NaN;
      const ifMax = ifValues.length ? Math.max(...ifValues) : NaN;
      const hasIfScale = Number.isFinite(ifMin) && Number.isFinite(ifMax) && (ifMax > ifMin);

      let html = '';
      // Simple table-like list.
      for (const r of results.slice(0, 80)) {
        const f = String(r.freqMHz || '');
        const ifDbN = (typeof r.ifDb === 'number') ? r.ifDb : null;
        const bbDbN = (typeof r.bbDb === 'number') ? r.bbDb : null;
        const auDbN = (typeof r.audioDb === 'number') ? r.audioDb : null;
        const ifDb = (typeof ifDbN === 'number') ? ifDbN.toFixed(1) : '-';
        const bbDb = (typeof bbDbN === 'number') ? bbDbN.toFixed(1) : '-';
        const auDb = (typeof auDbN === 'number') ? auDbN.toFixed(1) : '-';
        const st = (r.stereo === true) ? 'ST' : 'MO?';

        // Map dB-ish values into 0..100 for a simple meter.
        const toPct = (v) => {
          if (typeof v !== 'number' || !Number.isFinite(v)) return 0;
          // Heuristic: treat -60..0 as 0..100, clamp outside.
          const clamped = Math.max(-60, Math.min(0, v));
          return Math.round(((clamped + 60) / 60) * 100);
        };

        // IF: larger => stronger => longer bar (max IF => 100%).
        const ifPct = (hasIfScale && typeof ifDbN === 'number' && Number.isFinite(ifDbN))
          ? Math.round(((Math.max(ifMin, Math.min(ifMax, ifDbN)) - ifMin) / (ifMax - ifMin)) * 100)
          : null;

        // Fallback: BB/audio are typically larger (closer to 0) => stronger.
        const pct = (typeof ifPct === 'number')
          ? ifPct
          : Math.max(toPct(bbDbN), toPct(auDbN));

        html += `<div class="statusLine">
          <div style="min-width:240px">
            <div class="statusTitle">${f} MHz</div>
            <div class="statusValue">IF ${ifDb} / BB ${bbDb} / audio ${auDb} / ${st}</div>
            <div class="meter" aria-hidden="true"><span style="width:${pct}%"></span></div>
          </div>
          <div class="row">
            <button data-add="${f}">登録</button>
          </div>
        </div>`;
      }
      elScanResults.innerHTML = html;

      // Wire add buttons.
      for (const btn of elScanResults.querySelectorAll('button[data-add]')) {
        btn.addEventListener('click', async (ev) => {
          const mhz = String(ev.currentTarget.getAttribute('data-add') || '');
          const v = Number(mhz);
          if (!Number.isFinite(v)) return;
          try {
            await api('/api/presets/add', { freqMHz: v });
            await loadPresets();
            setError('');
          } catch (e) {
            setError(e);
          }
        });
      }
    }

    // Persist admin token locally (optional).
    try {
      const saved = localStorage.getItem('adminToken') || '';
      if (elAdminToken && saved) elAdminToken.value = saved;
      if (elAdminToken) {
        elAdminToken.addEventListener('input', () => {
          try { localStorage.setItem('adminToken', String(elAdminToken.value || '')); } catch { }
        });
      }
    } catch { }

    if (elServerRestart) {
      elServerRestart.addEventListener('click', () => { serverRestart(); });
    }

    async function refreshScanStatus() {
      try {
        const level = String(elScanLevel && elScanLevel.value ? elScanLevel.value : 'medium');
        const res = await fetch('/api/scan/status?level=' + encodeURIComponent(level));
        const json = await res.json();
        renderScanResults(json);
      } catch {
        // ignore
      }
    }

    async function refresh() {
      try {
        const res = await fetch('/api/status');
        const json = await res.json();

        // Determine stereo mode (prefer status.stereoMode; fallback to current UI selection).
        let stereoMode = '';
        if (json && typeof json.stereoMode === 'string') stereoMode = String(json.stereoMode || '').toLowerCase();
        if (!stereoMode) stereoMode = String(elForceStereo && elForceStereo.value ? elForceStereo.value : '').toLowerCase();

        // Now Playing (frequency + station name)
        const mhz = (json && typeof json.freqHz === 'number') ? (Number(json.freqHz) / 1_000_000.0) : Number(elFreq && elFreq.value);
        if (elPlayerNowFreq) elPlayerNowFreq.textContent = Number.isFinite(mhz) ? `${mhz.toFixed(1)} MHz` : '-';
        if (elPlayerNowName) elPlayerNowName.textContent = Number.isFinite(mhz) ? findPresetNameByMHz(mhz) : '-';

        updatePresetNavEnabled();

        // Human-friendly RX info.
        let effectiveStereo = null;
        if (stereoMode === 'stereo') effectiveStereo = true;
        else if (stereoMode === 'mono') effectiveStereo = false;
        else if (json && typeof json.stereoDetected === 'boolean') effectiveStereo = json.stereoDetected;

        let stereoText = '不明';
        if (typeof effectiveStereo === 'boolean') stereoText = effectiveStereo ? 'STEREO' : 'MONO';
        let pilotText = '';
        if (json && typeof json.pilotLevel === 'number') {
          pilotText = ` / pilot=${json.pilotLevel.toFixed(6)}`;
        }
        if (elRxInfo) elRxInfo.textContent = `受信: ${stereoText}${pilotText}`;

        setBadgeStreaming(!!(json && json.streaming));
        setBadgeStereo(typeof effectiveStereo === 'boolean' ? effectiveStereo : (json ? json.stereoDetected : null));
        if (json && json.delivery) {
          elBadgeDelivery.textContent = '配信: ' + String(json.delivery).toUpperCase();
        }

        elStatus.textContent = JSON.stringify(json, null, 2);
        if (json && json.lastError) {
          setError(json.lastError);
        }
      } catch (e) {
        elStatus.textContent = String(e);
      }
    }

    async function loadConfig() {
      try {
        const res = await fetch('/api/config');
        const json = await res.json();
        if (json && json.delivery) elDelivery.value = String(json.delivery);
        if (json && json.format) elFmt.value = String(json.format);
        if (json && typeof json.bufferSeconds === 'number') elBuf.value = String(json.bufferSeconds);
        if (json && typeof json.hlsBitrateKbps === 'number') elHlsKbps.value = String(json.hlsBitrateKbps);
        if (json && typeof json.rtlGainDb === 'number') elGain.value = String(json.rtlGainDb);
        if (json && typeof json.rtlAgc === 'boolean') elRtlAgc.value = json.rtlAgc ? 'on' : 'off';
        if (json && typeof json.stereoMode === 'string') {
          const m = String(json.stereoMode || '').toLowerCase();
          if (m === 'mono' || m === 'stereo' || m === 'auto') elForceStereo.value = m;
        } else if (json && typeof json.forceStereo === 'boolean') {
          elForceStereo.value = json.forceStereo ? 'stereo' : 'auto';
        }
      } catch (e) {
        // ignore
      }

      applyFormatSupportUI();
    }

    elPreset.addEventListener('change', () => {
      const v = String(elPreset.value || '').trim();
      if (!v) return;
      const mhz = Number(v);
      if (!Number.isFinite(mhz)) return;
      elFreq.value = mhz.toFixed(1);
      renderPresetGrid(lastPresets);
      renderPresetManageList(lastPresets);
    });

    if (elPresetPrev) {
      elPresetPrev.addEventListener('click', async (ev) => {
        ev.preventDefault();
        await navigatePreset(-1);
      });
    }
    if (elPresetNext) {
      elPresetNext.addEventListener('click', async (ev) => {
        ev.preventDefault();
        await navigatePreset(1);
      });
    }

    if (elPresetAddCurrent) {
      elPresetAddCurrent.addEventListener('click', async () => {
        const mhz = Number(elFreq.value);
        if (!Number.isFinite(mhz)) {
          setError('周波数が不正です');
          return;
        }
        try {
          await api('/api/presets/add', { freqMHz: mhz, name: '-' });
          await loadPresets();
          toast('プリセットに追加しました');
          setError('');
        } catch (e) {
          setError(e);
        }
      });
    }

    elScanGo.addEventListener('click', scanStart);
    elScanStop.addEventListener('click', scanStop);

    elScanAddAll.addEventListener('click', async () => {
      try {
        const list = Array.isArray(lastScanResults) ? lastScanResults : [];
        const mhzList = list
          .map(r => Number(r && r.freqMHz))
          .filter(v => Number.isFinite(v));
        if (!mhzList.length) {
          setError('登録できる発見局がありません');
          return;
        }
        await api('/api/presets/addMany', { freqMHzList: mhzList });
        await loadPresets();
        setError('');
      } catch (e) {
        setError(e);
      }
    });

    async function saveConfig() {
      const delivery = String(elDelivery.value || 'hls');
      const fmt = String(elFmt.value || 'mp3');
      if (delivery !== 'hls' && !canPlayDirectFormat(fmt)) {
        setError('Direct配信はMP3/WAVのみ対応です（AACはHLSを選んでください）');
        return;
      }
      const bufferSeconds = Number(elBuf.value);
      if (!Number.isFinite(bufferSeconds) || bufferSeconds < 0 || bufferSeconds > 60) {
        setError('バッファ(秒)は 0〜60 の範囲で指定してください');
        return;
      }

      const hlsBitrateKbps = Number(elHlsKbps.value);
      if (!Number.isFinite(hlsBitrateKbps) || hlsBitrateKbps < 32 || hlsBitrateKbps > 512) {
        setError('HLS kbps は 32〜512 の範囲で指定してください');
        return;
      }

      const rtlGainDb = Number(elGain.value);
      if (!Number.isFinite(rtlGainDb) || rtlGainDb < 0 || rtlGainDb > 100) {
        setError('RTL ゲイン(dB)は 0〜100 の範囲で指定してください');
        return;
      }

      const rtlAgc = (String(elRtlAgc.value || 'off') === 'on');
      const stereoMode = String(elForceStereo.value || 'auto');

      try {
        // Keep legacy forceStereo for backward compatibility.
        await api('/api/config', { delivery, format: fmt, bufferSeconds, hlsBitrateKbps, rtlGainDb, rtlAgc, stereoMode, forceStereo: (stereoMode === 'stereo') });
      } catch (e) {
        setError(e);
      }
    }

    async function waitForHlsReady(timeoutMs) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          const res = await fetch('/api/hls/ready');
          const json = await res.json();
          if (json && json.ready) return true;
        } catch (e) {
          // ignore
        }
        await new Promise(r => setTimeout(r, 250));
      }
      return false;
    }

    async function waitUntilStopped(timeoutMs) {
      const start = Date.now();
      while (Date.now() - start < timeoutMs) {
        try {
          const res = await fetch('/api/status', { cache: 'no-store' });
          const json = await res.json();
          const streaming = !!(json && (json.streaming || json.hlsRunning));
          if (!streaming) return true;
        } catch {
          // ignore
        }
        await new Promise(r => setTimeout(r, 200));
      }
      return false;
    }

    function stopPlayback() {
      try {
        if (hls) {
          hls.destroy();
          hls = null;
        }
      } catch {}
      elAudio.pause();
      elAudio.removeAttribute('src');
      elAudio.load();
    }

    async function playHls() {
      setError('HLSを準備中...');
      const ok = await waitForHlsReady(8000);
      if (!ok) {
        throw new Error('HLSの準備が完了しませんでした（m3u8が生成されていない可能性）');
      }

      const url = '/hls/stream.m3u8?ts=' + Date.now();

      stopPlayback();

      // Prefer hls.js when available (Chrome/Edge). Do NOT try "native" HLS on Chrome.
      if (window.Hls && window.Hls.isSupported()) {
        hls = new window.Hls({
          // keep startup latency low
          liveSyncDurationCount: 2,
          liveMaxLatencyDurationCount: 6,
        });
        hls.loadSource(url);
        hls.attachMedia(elAudio);
        await new Promise((resolve, reject) => {
          const onErr = (event, data) => {
            if (data && data.fatal) {
              const detail = (data.details ? String(data.details) : '');
              const reason = (data.reason ? String(data.reason) : '');
              reject(new Error('HLS fatal error: ' + data.type + (detail ? ' / ' + detail : '') + (reason ? ' / ' + reason : '')));
            }
          };
          hls.on(window.Hls.Events.MANIFEST_PARSED, resolve);
          hls.on(window.Hls.Events.ERROR, onErr);
        });
        await elAudio.play();
        setError('');
        return;
      }

      // Safari can play HLS natively.
      const ua = navigator.userAgent || '';
      const isSafari = /Safari\//.test(ua) && !/Chrome\//.test(ua) && !/Chromium\//.test(ua) && !/Edg\//.test(ua);
      if (isSafari && elAudio.canPlayType('application/vnd.apple.mpegurl')) {
        elAudio.src = url;
        elAudio.load();
        await elAudio.play();
        setError('');
        return;
      }

      if (!window.Hls) {
        throw new Error('hls.js が読み込めていません（/vendor/hls.js か CDN へのアクセスが必要です）');
      }
      throw new Error('このブラウザはHLSを再生できません（MSE非対応の可能性）');
    }

    async function startReceiving(mhz) {
      if (isBusy) return;
      setError('');
      if (!Number.isFinite(mhz) || mhz <= 0) {
        setError('周波数(MHz)が不正です');
        return;
      }

      setBusy(true);

      await saveConfig();
      if (elErr.textContent) {
        setBusy(false);
        await refresh();
        return;
      }

      // If currently receiving, enforce stop -> start to avoid stale HLS playlist / player state.
      try {
        const res = await fetch('/api/status', { cache: 'no-store' });
        const st = await res.json();
        const streaming = !!(st && (st.streaming || st.hlsRunning));
        if (streaming) {
          try { await api('/api/stop'); } catch {}
          stopPlayback();
          const stopped = await waitUntilStopped(6000);
          if (!stopped) {
            setError('停止に時間がかかっています。もう一度お試しください');
            setBusy(false);
            await refresh();
            return;
          }
        }
      } catch {
        // ignore and continue
      }

      try {
        await api('/api/start', { freqMHz: mhz });
      } catch (e) {
        setError(e);
        setBusy(false);
        await refresh();
        return;
      }

      const delivery = String(elDelivery.value || 'hls');
      const fmt = String(elFmt.value || 'mp3');

      try {
        if (delivery === 'hls') {
          await playHls();
        } else {
          // Direct stream
          stopPlayback();
          elAudio.src = '/stream?fmt=' + encodeURIComponent(fmt) + '&ts=' + Date.now();
          elAudio.load();
          await elAudio.play();
        }
      } catch (e) {
        setError(e);
      }
      setBusy(false);
      await refresh();
    }

    elStart.addEventListener('click', async () => {
      const mhz = Number(elFreq.value);
      await startReceiving(mhz);
    });

    elDelivery.addEventListener('change', () => {
      setError('');
      applyDeliveryUI();
    });

    elStop.addEventListener('click', async () => {
      if (isBusy) return;
      setError('');
      try {
        await api('/api/stop');
      } catch (e) {
        setError(e);
      }
      stopPlayback();
      await refresh();
    });

    elCopyUrl.addEventListener('click', async () => {
      updateUiUrl();
      const txt = elUiUrl.textContent || '';
      try {
        await navigator.clipboard.writeText(txt);
        toast('URLをコピーしました');
      } catch {
        // Fallback
        try {
          const ta = document.createElement('textarea');
          ta.value = txt;
          ta.style.position = 'fixed';
          ta.style.opacity = '0';
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          document.execCommand('copy');
          ta.remove();
          toast('URLをコピーしました');
        } catch {}
      }
    });

    // Ensure we start from a stopped state on page load.
    elAudio.pause();
    elAudio.removeAttribute('src');
    elAudio.load();
    fetch('/api/stop', { method: 'POST' }).catch(() => {});
    updateUiUrl();
    loadPresets();
    loadConfig();
    refresh();
    setInterval(refresh, 2000);
    setInterval(refreshScanStatus, 800);

    // Stop stream when leaving/reloading the page (best-effort).
    window.addEventListener('beforeunload', () => {
      try { navigator.sendBeacon('/api/stop', ''); } catch {}
    });
  </script>
</body>
</html>
